/**\n * Mobile Optimizations and Touch-Friendly Enhancements\n * Provides mobile-specific features, gestures, and optimizations\n */\n\nclass MobileOptimizations {\n  constructor() {\n    this.isMobile = this.detectMobile();\n    this.touchStartX = 0;\n    this.touchStartY = 0;\n    this.isSwipeGesture = false;\n    this.lastTouchTime = 0;\n    this.doubleTapDelay = 300;\n    this.swipeThreshold = 50;\n    this.init();\n  }\n\n  detectMobile() {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||\n           window.innerWidth <= 768;\n  }\n\n  init() {\n    if (!this.isMobile) return;\n    \n    this.optimizeMobileInterface();\n    this.initTouchGestures();\n    this.createMobileToolbar();\n    this.optimizeForKeyboard();\n    this.addPullToRefresh();\n    this.optimizeScrolling();\n    this.addTouchFeedback();\n    this.handleOrientationChanges();\n    this.optimizeImageLoading();\n    this.addOfflineSupport();\n  }\n\n  optimizeMobileInterface() {\n    // Add mobile class to body\n    document.body.classList.add('mobile-optimized');\n    \n    // Optimize viewport\n    this.setViewportMeta();\n    \n    // Make interactive elements touch-friendly\n    this.optimizeTouchTargets();\n    \n    // Optimize font sizes for mobile\n    this.optimizeMobileFonts();\n    \n    // Add mobile-specific styles dynamically\n    this.addMobileStyles();\n  }\n\n  setViewportMeta() {\n    let viewport = document.querySelector('meta[name=\"viewport\"]');\n    if (!viewport) {\n      viewport = document.createElement('meta');\n      viewport.name = 'viewport';\n      document.head.appendChild(viewport);\n    }\n    viewport.content = 'width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes, viewport-fit=cover';\n  }\n\n  optimizeTouchTargets() {\n    const minTouchSize = 44; // 44px minimum touch target\n    \n    // Find and enhance small interactive elements\n    const interactiveElements = document.querySelectorAll('button, a, input, select, textarea, [role=\"button\"], [tabindex]');\n    \n    interactiveElements.forEach(element => {\n      const rect = element.getBoundingClientRect();\n      if (rect.width < minTouchSize || rect.height < minTouchSize) {\n        element.style.minWidth = `${minTouchSize}px`;\n        element.style.minHeight = `${minTouchSize}px`;\n        element.style.display = element.style.display || 'inline-flex';\n        element.style.alignItems = 'center';\n        element.style.justifyContent = 'center';\n        element.classList.add('touch-optimized');\n      }\n    });\n    \n    // Add touch feedback class\n    interactiveElements.forEach(element => {\n      element.classList.add('touch-feedback');\n    });\n  }\n\n  optimizeMobileFonts() {\n    // Prevent font size adjustment on iOS\n    document.documentElement.style.webkitTextSizeAdjust = '100%';\n    \n    // Optimize font sizes for mobile reading\n    const style = document.createElement('style');\n    style.textContent = `\n      @media (max-width: 768px) {\n        .md-typeset {\n          font-size: 16px !important; /* Prevent zoom on iOS */\n          line-height: 1.6;\n        }\n        .md-typeset h1 { font-size: 1.8rem; }\n        .md-typeset h2 { font-size: 1.5rem; }\n        .md-typeset h3 { font-size: 1.25rem; }\n        .md-typeset h4 { font-size: 1.1rem; }\n        input, textarea, select {\n          font-size: 16px !important; /* Prevent zoom */\n        }\n      }\n    `;\n    document.head.appendChild(style);\n  }\n\n  initTouchGestures() {\n    let touchStartTime = 0;\n    let lastTap = 0;\n    \n    document.addEventListener('touchstart', (e) => {\n      this.touchStartX = e.touches[0].clientX;\n      this.touchStartY = e.touches[0].clientY;\n      touchStartTime = Date.now();\n      this.isSwipeGesture = false;\n      \n      // Handle double tap\n      const currentTime = Date.now();\n      const tapLength = currentTime - lastTap;\n      if (tapLength < this.doubleTapDelay && tapLength > 0) {\n        this.handleDoubleTap(e);\n      }\n      lastTap = currentTime;\n    }, { passive: true });\n    \n    document.addEventListener('touchmove', (e) => {\n      if (!this.touchStartX || !this.touchStartY) return;\n      \n      const touchEndX = e.touches[0].clientX;\n      const touchEndY = e.touches[0].clientY;\n      const deltaX = this.touchStartX - touchEndX;\n      const deltaY = this.touchStartY - touchEndY;\n      \n      // Determine if this is a swipe gesture\n      if (Math.abs(deltaX) > this.swipeThreshold || Math.abs(deltaY) > this.swipeThreshold) {\n        this.isSwipeGesture = true;\n      }\n    }, { passive: true });\n    \n    document.addEventListener('touchend', (e) => {\n      if (!this.isSwipeGesture || !this.touchStartX || !this.touchStartY) {\n        this.touchStartX = 0;\n        this.touchStartY = 0;\n        return;\n      }\n      \n      const touchEndX = e.changedTouches[0].clientX;\n      const touchEndY = e.changedTouches[0].clientY;\n      const deltaX = this.touchStartX - touchEndX;\n      const deltaY = this.touchStartY - touchEndY;\n      const touchDuration = Date.now() - touchStartTime;\n      \n      // Only process quick swipes\n      if (touchDuration > 500) return;\n      \n      this.handleSwipeGesture(deltaX, deltaY, e);\n      \n      this.touchStartX = 0;\n      this.touchStartY = 0;\n    }, { passive: true });\n  }\n\n  handleSwipeGesture(deltaX, deltaY, event) {\n    const absX = Math.abs(deltaX);\n    const absY = Math.abs(deltaY);\n    \n    // Horizontal swipes\n    if (absX > absY && absX > this.swipeThreshold) {\n      if (deltaX > 0) {\n        // Swipe left - next page\n        this.navigateNext();\n        this.showSwipeIndicator('Next page', 'right');\n      } else {\n        // Swipe right - previous page\n        this.navigatePrevious();\n        this.showSwipeIndicator('Previous page', 'left');\n      }\n    }\n    \n    // Vertical swipes\n    else if (absY > absX && absY > this.swipeThreshold) {\n      if (deltaY > 0) {\n        // Swipe up - scroll to bottom or next section\n        this.scrollToNextSection();\n        this.showSwipeIndicator('Next section', 'up');\n      } else {\n        // Swipe down - scroll to top or previous section\n        this.scrollToPreviousSection();\n        this.showSwipeIndicator('Previous section', 'down');\n      }\n    }\n  }\n\n  handleDoubleTap(event) {\n    // Prevent default zoom behavior\n    event.preventDefault();\n    \n    const target = event.target.closest('.md-typeset h1, .md-typeset h2, .md-typeset h3');\n    if (target) {\n      // Double tap on heading - toggle section\n      this.toggleSection(target);\n    } else {\n      // Double tap anywhere else - toggle reading mode\n      this.toggleReadingMode();\n    }\n  }\n\n  navigateNext() {\n    const nextLink = document.querySelector('.md-footer__link--next, a[rel=\"next\"]');\n    if (nextLink) {\n      nextLink.click();\n    }\n  }\n\n  navigatePrevious() {\n    const prevLink = document.querySelector('.md-footer__link--prev, a[rel=\"prev\"]');\n    if (prevLink) {\n      prevLink.click();\n    }\n  }\n\n  scrollToNextSection() {\n    const headings = document.querySelectorAll('.md-typeset h1, .md-typeset h2, .md-typeset h3');\n    const currentScroll = window.scrollY;\n    \n    for (const heading of headings) {\n      const headingTop = heading.getBoundingClientRect().top + currentScroll;\n      if (headingTop > currentScroll + 100) {\n        heading.scrollIntoView({ behavior: 'smooth', block: 'start' });\n        return;\n      }\n    }\n    \n    // If no next section, scroll to bottom\n    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });\n  }\n\n  scrollToPreviousSection() {\n    const headings = document.querySelectorAll('.md-typeset h1, .md-typeset h2, .md-typeset h3');\n    const currentScroll = window.scrollY;\n    \n    for (let i = headings.length - 1; i >= 0; i--) {\n      const heading = headings[i];\n      const headingTop = heading.getBoundingClientRect().top + currentScroll;\n      if (headingTop < currentScroll - 100) {\n        heading.scrollIntoView({ behavior: 'smooth', block: 'start' });\n        return;\n      }\n    }\n    \n    // If no previous section, scroll to top\n    window.scrollTo({ top: 0, behavior: 'smooth' });\n  }\n\n  toggleSection(heading) {\n    const nextElement = heading.nextElementSibling;\n    if (nextElement) {\n      const isHidden = nextElement.style.display === 'none';\n      nextElement.style.display = isHidden ? 'block' : 'none';\n      this.showSwipeIndicator(isHidden ? 'Section expanded' : 'Section collapsed', 'none');\n    }\n  }\n\n  toggleReadingMode() {\n    document.body.classList.toggle('mobile-reading-mode');\n    const isReadingMode = document.body.classList.contains('mobile-reading-mode');\n    this.showSwipeIndicator(isReadingMode ? 'Reading mode on' : 'Reading mode off', 'none');\n  }\n\n  showSwipeIndicator(text, direction) {\n    const indicator = document.createElement('div');\n    indicator.className = `swipe-indicator ${direction}`;\n    indicator.innerHTML = `\n      <div class=\"swipe-indicator-content\">\n        <div class=\"swipe-indicator-icon\">${this.getDirectionIcon(direction)}</div>\n        <div class=\"swipe-indicator-text\">${text}</div>\n      </div>\n    `;\n    \n    document.body.appendChild(indicator);\n    \n    setTimeout(() => {\n      indicator.classList.add('show');\n    }, 50);\n    \n    setTimeout(() => {\n      indicator.classList.remove('show');\n      setTimeout(() => {\n        if (document.body.contains(indicator)) {\n          document.body.removeChild(indicator);\n        }\n      }, 300);\n    }, 1500);\n  }\n\n  getDirectionIcon(direction) {\n    const icons = {\n      left: 'üëà',\n      right: 'üëâ',\n      up: 'üëÜ',\n      down: 'üëá',\n      none: '‚ú®'\n    };\n    return icons[direction] || '‚ú®';\n  }\n\n  createMobileToolbar() {\n    const toolbar = document.createElement('div');\n    toolbar.className = 'mobile-toolbar';\n    toolbar.innerHTML = `\n      <div class=\"mobile-toolbar-item\" data-action=\"home\">\n        <div class=\"mobile-toolbar-icon\">üè†</div>\n        <div class=\"mobile-toolbar-label\">Home</div>\n      </div>\n      <div class=\"mobile-toolbar-item\" data-action=\"search\">\n        <div class=\"mobile-toolbar-icon\">üîç</div>\n        <div class=\"mobile-toolbar-label\">Search</div>\n      </div>\n      <div class=\"mobile-toolbar-item\" data-action=\"bookmark\">\n        <div class=\"mobile-toolbar-icon\">üìñ</div>\n        <div class=\"mobile-toolbar-label\">Bookmark</div>\n      </div>\n      <div class=\"mobile-toolbar-item\" data-action=\"menu\">\n        <div class=\"mobile-toolbar-icon\">‚ò∞</div>\n        <div class=\"mobile-toolbar-label\">Menu</div>\n      </div>\n      <div class=\"mobile-toolbar-item\" data-action=\"progress\">\n        <div class=\"mobile-toolbar-icon\">üìä</div>\n        <div class=\"mobile-toolbar-label\">Progress</div>\n      </div>\n    `;\n    \n    document.body.appendChild(toolbar);\n    \n    // Show toolbar after page load\n    setTimeout(() => {\n      toolbar.classList.add('active');\n    }, 1000);\n    \n    // Bind toolbar events\n    toolbar.addEventListener('click', (e) => {\n      const item = e.target.closest('.mobile-toolbar-item');\n      if (!item) return;\n      \n      const action = item.dataset.action;\n      this.handleToolbarAction(action, item);\n    });\n    \n    // Hide toolbar when scrolling down, show when scrolling up\n    let lastScrollY = window.scrollY;\n    let scrollTimeout;\n    \n    window.addEventListener('scroll', () => {\n      clearTimeout(scrollTimeout);\n      const currentScrollY = window.scrollY;\n      \n      if (currentScrollY > lastScrollY && currentScrollY > 100) {\n        // Scrolling down\n        toolbar.style.transform = 'translateY(100%)';\n      } else {\n        // Scrolling up\n        toolbar.style.transform = 'translateY(0)';\n      }\n      \n      lastScrollY = currentScrollY;\n      \n      // Show toolbar after scrolling stops\n      scrollTimeout = setTimeout(() => {\n        toolbar.style.transform = 'translateY(0)';\n      }, 1000);\n    }, { passive: true });\n  }\n\n  handleToolbarAction(action, item) {\n    // Provide visual feedback\n    item.classList.add('active');\n    setTimeout(() => item.classList.remove('active'), 200);\n    \n    switch (action) {\n      case 'home':\n        window.location.href = '/';\n        break;\n      case 'search':\n        this.openMobileSearch();\n        break;\n      case 'bookmark':\n        this.toggleBookmark();\n        break;\n      case 'menu':\n        this.toggleMobileMenu();\n        break;\n      case 'progress':\n        this.openProgressPanel();\n        break;\n    }\n  }\n\n  openMobileSearch() {\n    if (window.advancedSearch) {\n      window.advancedSearch.openAdvancedSearch();\n    } else {\n      const searchInput = document.querySelector('.md-search__input');\n      if (searchInput) {\n        searchInput.focus();\n      }\n    }\n  }\n\n  toggleBookmark() {\n    if (window.personalization) {\n      window.personalization.bookmarkCurrentPage();\n    } else {\n      // Fallback bookmark functionality\n      this.showSwipeIndicator('Page bookmarked', 'none');\n    }\n  }\n\n  toggleMobileMenu() {\n    const sidebar = document.querySelector('.md-sidebar--primary');\n    if (sidebar) {\n      const isOpen = sidebar.classList.contains('mobile-menu-open');\n      sidebar.classList.toggle('mobile-menu-open', !isOpen);\n      \n      // Add backdrop\n      if (!isOpen) {\n        const backdrop = document.createElement('div');\n        backdrop.className = 'mobile-menu-backdrop';\n        backdrop.onclick = () => {\n          sidebar.classList.remove('mobile-menu-open');\n          document.body.removeChild(backdrop);\n        };\n        document.body.appendChild(backdrop);\n      }\n    }\n  }\n\n  openProgressPanel() {\n    if (window.learningProgress) {\n      // Open learning progress panel\n      const event = new CustomEvent('openProgressPanel');\n      window.dispatchEvent(event);\n    } else {\n      this.showSwipeIndicator('Progress tracking available soon', 'none');\n    }\n  }\n\n  optimizeForKeyboard() {\n    // Handle virtual keyboard appearance\n    let initialViewportHeight = window.visualViewport?.height || window.innerHeight;\n    \n    const handleViewportChange = () => {\n      const currentHeight = window.visualViewport?.height || window.innerHeight;\n      const heightDifference = initialViewportHeight - currentHeight;\n      \n      if (heightDifference > 150) {\n        // Keyboard is likely open\n        document.body.classList.add('keyboard-open');\n        this.adjustForKeyboard(heightDifference);\n      } else {\n        // Keyboard is likely closed\n        document.body.classList.remove('keyboard-open');\n        this.restoreAfterKeyboard();\n      }\n    };\n    \n    if (window.visualViewport) {\n      window.visualViewport.addEventListener('resize', handleViewportChange);\n    } else {\n      window.addEventListener('resize', handleViewportChange);\n    }\n  }\n\n  adjustForKeyboard(heightDifference) {\n    // Hide mobile toolbar when keyboard is open\n    const toolbar = document.querySelector('.mobile-toolbar');\n    if (toolbar) {\n      toolbar.style.transform = 'translateY(100%)';\n    }\n    \n    // Scroll focused element into view\n    const focusedElement = document.activeElement;\n    if (focusedElement && focusedElement !== document.body) {\n      setTimeout(() => {\n        focusedElement.scrollIntoView({ behavior: 'smooth', block: 'center' });\n      }, 300);\n    }\n  }\n\n  restoreAfterKeyboard() {\n    // Restore mobile toolbar\n    const toolbar = document.querySelector('.mobile-toolbar');\n    if (toolbar) {\n      toolbar.style.transform = 'translateY(0)';\n    }\n  }\n\n  addPullToRefresh() {\n    let startY = 0;\n    let pullDistance = 0;\n    let isPulling = false;\n    let refreshThreshold = 80;\n    \n    const refreshIndicator = document.createElement('div');\n    refreshIndicator.className = 'pull-to-refresh';\n    refreshIndicator.innerHTML = `\n      <div class=\"pull-refresh-icon\">‚Üì</div>\n      <div class=\"pull-refresh-text\">Pull to refresh</div>\n    `;\n    document.body.appendChild(refreshIndicator);\n    \n    document.addEventListener('touchstart', (e) => {\n      if (window.scrollY === 0) {\n        startY = e.touches[0].clientY;\n        isPulling = true;\n      }\n    }, { passive: true });\n    \n    document.addEventListener('touchmove', (e) => {\n      if (!isPulling || window.scrollY > 0) return;\n      \n      pullDistance = e.touches[0].clientY - startY;\n      if (pullDistance > 0) {\n        e.preventDefault();\n        \n        const progress = Math.min(pullDistance / refreshThreshold, 1);\n        refreshIndicator.style.transform = `translateY(${pullDistance * 0.5}px) rotate(${progress * 180}deg)`;\n        refreshIndicator.style.opacity = progress;\n        \n        if (pullDistance > refreshThreshold) {\n          refreshIndicator.classList.add('ready');\n          refreshIndicator.querySelector('.pull-refresh-text').textContent = 'Release to refresh';\n        } else {\n          refreshIndicator.classList.remove('ready');\n          refreshIndicator.querySelector('.pull-refresh-text').textContent = 'Pull to refresh';\n        }\n      }\n    });\n    \n    document.addEventListener('touchend', () => {\n      if (!isPulling) return;\n      \n      if (pullDistance > refreshThreshold) {\n        this.refreshPage();\n      }\n      \n      // Reset\n      isPulling = false;\n      pullDistance = 0;\n      refreshIndicator.style.transform = 'translateY(-100px)';\n      refreshIndicator.style.opacity = '0';\n      refreshIndicator.classList.remove('ready');\n    }, { passive: true });\n  }\n\n  refreshPage() {\n    const refreshIndicator = document.querySelector('.pull-to-refresh');\n    refreshIndicator.classList.add('refreshing');\n    refreshIndicator.querySelector('.pull-refresh-text').textContent = 'Refreshing...';\n    \n    // Simulate refresh (in a real app, this would reload data)\n    setTimeout(() => {\n      window.location.reload();\n    }, 1000);\n  }\n\n  optimizeScrolling() {\n    // Add momentum scrolling for iOS\n    document.documentElement.style.webkitOverflowScrolling = 'touch';\n    \n    // Smooth scroll polyfill for older browsers\n    if (!('scrollBehavior' in document.documentElement.style)) {\n      this.addSmoothScrollPolyfill();\n    }\n    \n    // Add scroll position indicator\n    this.addScrollIndicator();\n  }\n\n  addSmoothScrollPolyfill() {\n    const links = document.querySelectorAll('a[href^=\"#\"]');\n    links.forEach(link => {\n      link.addEventListener('click', (e) => {\n        e.preventDefault();\n        const target = document.querySelector(link.getAttribute('href'));\n        if (target) {\n          this.smoothScrollTo(target.offsetTop, 500);\n        }\n      });\n    });\n  }\n\n  smoothScrollTo(targetY, duration) {\n    const startY = window.scrollY;\n    const distance = targetY - startY;\n    const startTime = performance.now();\n    \n    const scrollStep = (currentTime) => {\n      const elapsed = currentTime - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n      const ease = this.easeOutCubic(progress);\n      \n      window.scrollTo(0, startY + (distance * ease));\n      \n      if (progress < 1) {\n        requestAnimationFrame(scrollStep);\n      }\n    };\n    \n    requestAnimationFrame(scrollStep);\n  }\n\n  easeOutCubic(t) {\n    return 1 - Math.pow(1 - t, 3);\n  }\n\n  addScrollIndicator() {\n    const indicator = document.createElement('div');\n    indicator.className = 'mobile-scroll-indicator';\n    document.body.appendChild(indicator);\n    \n    window.addEventListener('scroll', () => {\n      const scrollTop = window.scrollY;\n      const documentHeight = document.documentElement.scrollHeight - window.innerHeight;\n      const scrollPercentage = (scrollTop / documentHeight) * 100;\n      \n      indicator.style.width = `${scrollPercentage}%`;\n    }, { passive: true });\n  }\n\n  addTouchFeedback() {\n    // Add haptic feedback for supported devices\n    const addFeedback = (element, intensity = 'light') => {\n      element.addEventListener('touchstart', () => {\n        if (navigator.vibrate) {\n          navigator.vibrate(intensity === 'light' ? 10 : 25);\n        }\n      }, { passive: true });\n    };\n    \n    // Add feedback to interactive elements\n    document.querySelectorAll('button, .md-button, .card, .touch-feedback').forEach(element => {\n      addFeedback(element);\n    });\n    \n    // Add visual touch feedback\n    this.addVisualTouchFeedback();\n  }\n\n  addVisualTouchFeedback() {\n    const style = document.createElement('style');\n    style.textContent = `\n      .touch-feedback {\n        position: relative;\n        overflow: hidden;\n      }\n      \n      .touch-feedback::before {\n        content: '';\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        width: 0;\n        height: 0;\n        border-radius: 50%;\n        background: rgba(255, 255, 255, 0.3);\n        transform: translate(-50%, -50%);\n        transition: width 0.6s, height 0.6s, opacity 0.6s;\n        opacity: 0;\n        pointer-events: none;\n      }\n      \n      .touch-feedback:active::before {\n        width: 200px;\n        height: 200px;\n        opacity: 1;\n        transition: width 0s, height 0s, opacity 0s;\n      }\n    `;\n    document.head.appendChild(style);\n  }\n\n  handleOrientationChanges() {\n    window.addEventListener('orientationchange', () => {\n      // Hide address bar on iOS after orientation change\n      setTimeout(() => {\n        window.scrollTo(0, 1);\n        setTimeout(() => window.scrollTo(0, 0), 0);\n      }, 500);\n      \n      // Recalculate layout\n      this.recalculateLayout();\n    });\n  }\n\n  recalculateLayout() {\n    // Trigger reflow to fix layout issues after orientation change\n    const body = document.body;\n    const originalDisplay = body.style.display;\n    body.style.display = 'none';\n    body.offsetHeight; // Trigger reflow\n    body.style.display = originalDisplay;\n  }\n\n  optimizeImageLoading() {\n    // Add lazy loading to images\n    const images = document.querySelectorAll('img:not([loading])');\n    images.forEach(img => {\n      img.loading = 'lazy';\n      img.decoding = 'async';\n    });\n    \n    // Add responsive image handling\n    this.addResponsiveImages();\n  }\n\n  addResponsiveImages() {\n    const images = document.querySelectorAll('img');\n    images.forEach(img => {\n      img.addEventListener('load', () => {\n        img.classList.add('loaded');\n      });\n      \n      img.addEventListener('error', () => {\n        img.classList.add('error');\n        // Add fallback or placeholder\n      });\n    });\n  }\n\n  addOfflineSupport() {\n    // Show offline indicator\n    window.addEventListener('offline', () => {\n      this.showOfflineIndicator();\n    });\n    \n    window.addEventListener('online', () => {\n      this.hideOfflineIndicator();\n    });\n    \n    // Check initial state\n    if (!navigator.onLine) {\n      this.showOfflineIndicator();\n    }\n  }\n\n  showOfflineIndicator() {\n    let indicator = document.querySelector('.offline-indicator');\n    if (!indicator) {\n      indicator = document.createElement('div');\n      indicator.className = 'offline-indicator';\n      indicator.innerHTML = `\n        <div class=\"offline-content\">\n          <span class=\"offline-icon\">üì¥</span>\n          <span class=\"offline-text\">You're offline</span>\n        </div>\n      `;\n      document.body.appendChild(indicator);\n    }\n    \n    setTimeout(() => {\n      indicator.classList.add('show');\n    }, 100);\n  }\n\n  hideOfflineIndicator() {\n    const indicator = document.querySelector('.offline-indicator');\n    if (indicator) {\n      indicator.classList.remove('show');\n      setTimeout(() => {\n        if (document.body.contains(indicator)) {\n          document.body.removeChild(indicator);\n        }\n      }, 300);\n    }\n  }\n\n  addMobileStyles() {\n    const mobileCSS = `\n      /* Mobile Reading Mode */\n      .mobile-reading-mode .md-header,\n      .mobile-reading-mode .md-footer,\n      .mobile-reading-mode .mobile-toolbar {\n        opacity: 0.1;\n        transition: opacity 0.3s;\n      }\n      \n      .mobile-reading-mode .md-header:hover,\n      .mobile-reading-mode .md-footer:hover,\n      .mobile-reading-mode .mobile-toolbar:hover {\n        opacity: 1;\n      }\n      \n      .mobile-reading-mode .md-content {\n        padding: var(--spacing-xl) var(--spacing-md);\n        max-width: none;\n        font-size: 18px;\n        line-height: 1.7;\n      }\n      \n      /* Keyboard Open State */\n      .keyboard-open .mobile-toolbar {\n        transform: translateY(100%) !important;\n      }\n      \n      /* Mobile Menu */\n      .mobile-menu-open {\n        transform: translateX(0) !important;\n        visibility: visible !important;\n      }\n      \n      .mobile-menu-backdrop {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background: rgba(0, 0, 0, 0.5);\n        z-index: 99;\n        backdrop-filter: blur(4px);\n      }\n      \n      /* Touch Optimizations */\n      .touch-optimized {\n        -webkit-tap-highlight-color: transparent;\n        -webkit-touch-callout: none;\n        -webkit-user-select: none;\n        user-select: none;\n      }\n      \n      /* Swipe Indicators */\n      .swipe-indicator {\n        position: fixed;\n        bottom: 100px;\n        left: 50%;\n        transform: translateX(-50%) translateY(20px);\n        background: rgba(0, 0, 0, 0.8);\n        color: white;\n        padding: var(--spacing-md) var(--spacing-lg);\n        border-radius: var(--radius-lg);\n        font-size: 0.9rem;\n        opacity: 0;\n        transition: all 0.3s ease;\n        z-index: 10000;\n        backdrop-filter: blur(10px);\n      }\n      \n      .swipe-indicator.show {\n        opacity: 1;\n        transform: translateX(-50%) translateY(0);\n      }\n      \n      .swipe-indicator-content {\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-sm);\n      }\n      \n      .swipe-indicator-icon {\n        font-size: 1.2rem;\n      }\n      \n      /* Pull to Refresh */\n      .pull-to-refresh {\n        position: fixed;\n        top: -100px;\n        left: 50%;\n        transform: translateX(-50%);\n        background: var(--md-primary-fg-color);\n        color: white;\n        padding: var(--spacing-md);\n        border-radius: 0 0 var(--radius-lg) var(--radius-lg);\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-sm);\n        font-size: 0.9rem;\n        opacity: 0;\n        transition: all 0.3s ease;\n        z-index: 1000;\n      }\n      \n      .pull-to-refresh.ready {\n        background: var(--success-color);\n      }\n      \n      .pull-to-refresh.refreshing .pull-refresh-icon {\n        animation: spin 1s linear infinite;\n      }\n      \n      @keyframes spin {\n        from { transform: rotate(0deg); }\n        to { transform: rotate(360deg); }\n      }\n      \n      /* Mobile Scroll Indicator */\n      .mobile-scroll-indicator {\n        position: fixed;\n        top: 0;\n        left: 0;\n        height: 3px;\n        background: var(--md-primary-fg-color);\n        z-index: 1000;\n        transition: width 0.1s ease;\n        border-radius: 0 3px 3px 0;\n      }\n      \n      /* Offline Indicator */\n      .offline-indicator {\n        position: fixed;\n        top: 60px;\n        left: 50%;\n        transform: translateX(-50%) translateY(-20px);\n        background: var(--error-color);\n        color: white;\n        padding: var(--spacing-sm) var(--spacing-lg);\n        border-radius: var(--radius-md);\n        font-size: 0.9rem;\n        opacity: 0;\n        transition: all 0.3s ease;\n        z-index: 10000;\n      }\n      \n      .offline-indicator.show {\n        opacity: 1;\n        transform: translateX(-50%) translateY(0);\n      }\n      \n      .offline-content {\n        display: flex;\n        align-items: center;\n        gap: var(--spacing-sm);\n      }\n    `;\n    \n    const style = document.createElement('style');\n    style.textContent = mobileCSS;\n    document.head.appendChild(style);\n  }\n}\n\n// Initialize mobile optimizations\ndocument.addEventListener('DOMContentLoaded', () => {\n  window.mobileOptimizations = new MobileOptimizations();\n});\n\n// Handle page visibility changes\ndocument.addEventListener('visibilitychange', () => {\n  if (document.hidden) {\n    // Page is hidden - pause any animations or tracking\n  } else {\n    // Page is visible - resume\n    if (window.mobileOptimizations && window.mobileOptimizations.isMobile) {\n      // Recalculate layout in case of orientation change while hidden\n      setTimeout(() => {\n        window.mobileOptimizations.recalculateLayout();\n      }, 100);\n    }\n  }\n});"